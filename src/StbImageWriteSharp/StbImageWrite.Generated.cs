// Generated by Sichem at 10/14/2017 7:35:48 AM
// Heavily modified since then :)

using System;
using System.IO;
using System.IO.Compression;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using StbSharp;

namespace StbSharp
{
    public static unsafe partial class StbImageWrite
    {
        #region PNG Settings

        public static int stbi__flip_vertically_on_write = 0;
        public static int stbi_png_write_force_filter = -1;

        #endregion

        #region CRC Table

        public static uint[] crc_table =
        {
            0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
            0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
            0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
            0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
            0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
            0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
            0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
            0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
            0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
            0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
            0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
            0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
            0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
            0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
            0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
            0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
            0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
            0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
            0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
            0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
            0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
            0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
            0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
            0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
            0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
            0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
            0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
            0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
            0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
            0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
            0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
            0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
        };

        #endregion

        #region JPG Constants

        public static byte[] stbiw__jpg_ZigZag =
        {
            0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41,
            43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38,
            46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63
        };

        public static byte[] std_dc_luminance_nrcodes = { 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
        public static byte[] std_dc_luminance_values = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
        public static byte[] std_ac_luminance_nrcodes = { 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };

        public static byte[] std_ac_luminance_values =
        {
            0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,
            0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,
            0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37,
            0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83,
            0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
            0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
            0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
        };

        public static byte[] std_dc_chrominance_nrcodes = { 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
        public static byte[] std_dc_chrominance_values = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
        public static byte[] std_ac_chrominance_nrcodes = { 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };

        public static byte[] std_ac_chrominance_values =
        {
            0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
            0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1,
            0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36,
            0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
            0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
            0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a,
            0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
            0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
            0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
        };

        public static ushort[,] YDC_HT =
        {
            {0, 2}, {2, 3}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {14, 4}, {30, 5}, {62, 6}, {126, 7}, {254, 8}, {510, 9}
        };

        public static ushort[,] UVDC_HT =
        {
            {0, 2}, {1, 2}, {2, 2}, {6, 3}, {14, 4}, {30, 5}, {62, 6}, {126, 7}, {254, 8}, {510, 9}, {1022, 10}, {2046, 11}
        };

        public static ushort[,] YAC_HT =
        {
            {10, 4}, {0, 2}, {1, 2}, {4, 3}, {11, 4}, {26, 5}, {120, 7}, {248, 8}, {1014, 10}, {65410, 16},
            {65411, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {12, 4}, {27, 5}, {121, 7}, {502, 9},
            {2038, 11}, {65412, 16}, {65413, 16}, {65414, 16}, {65415, 16}, {65416, 16}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {28, 5}, {249, 8}, {1015, 10}, {4084, 12}, {65417, 16}, {65418, 16}, {65419, 16},
            {65420, 16}, {65421, 16}, {65422, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {58, 6}, {503, 9},
            {4085, 12}, {65423, 16}, {65424, 16}, {65425, 16}, {65426, 16}, {65427, 16}, {65428, 16}, {65429, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {59, 6}, {1016, 10}, {65430, 16}, {65431, 16},
            {65432, 16}, {65433, 16}, {65434, 16}, {65435, 16}, {65436, 16}, {65437, 16}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {122, 7}, {2039, 11}, {65438, 16}, {65439, 16}, {65440, 16}, {65441, 16},
            {65442, 16}, {65443, 16}, {65444, 16}, {65445, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {123, 7}, {4086, 12}, {65446, 16}, {65447, 16}, {65448, 16}, {65449, 16}, {65450, 16}, {65451, 16},
            {65452, 16}, {65453, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {250, 8}, {4087, 12},
            {65454, 16}, {65455, 16}, {65456, 16}, {65457, 16}, {65458, 16}, {65459, 16}, {65460, 16}, {65461, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {504, 9}, {32704, 15}, {65462, 16}, {65463, 16},
            {65464, 16}, {65465, 16}, {65466, 16}, {65467, 16}, {65468, 16}, {65469, 16}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {505, 9}, {65470, 16}, {65471, 16}, {65472, 16}, {65473, 16}, {65474, 16},
            {65475, 16}, {65476, 16}, {65477, 16}, {65478, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {506, 9}, {65479, 16}, {65480, 16}, {65481, 16}, {65482, 16},{65483, 16}, {65484, 16}, {65485, 16},
            {65486, 16}, {65487, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1017, 10}, {65488, 16},
            {65489, 16}, {65490, 16}, {65491, 16}, {65492, 16}, {65493, 16}, {65494, 16}, {65495, 16}, {65496, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1018, 10}, {65497, 16}, {65498, 16}, {65499, 16},
            {65500, 16}, {65501, 16}, {65502, 16}, {65503, 16}, {65504, 16}, {65505, 16}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {2040, 11}, {65506, 16}, {65507, 16}, {65508, 16}, {65509, 16}, {65510, 16},
            {65511, 16}, {65512, 16}, {65513, 16}, {65514, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {65515, 16}, {65516, 16}, {65517, 16}, {65518, 16}, {65519, 16}, {65520, 16}, {65521, 16}, {65522, 16},
            {65523, 16}, {65524, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {2041, 11}, {65525, 16}, {65526, 16},
            {65527, 16}, {65528, 16}, {65529, 16}, {65530, 16}, {65531, 16}, {65532, 16}, {65533, 16}, {65534, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}
        };

        public static ushort[,] UVAC_HT =
        {
            {0, 2}, {1, 2}, {4, 3}, {10, 4}, {24, 5}, {25, 5}, {56, 6}, {120, 7}, {500, 9}, {1014, 10}, {4084, 12},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {11, 4}, {57, 6}, {246, 8}, {501, 9}, {2038, 11},
            {4085, 12}, {65416, 16}, {65417, 16}, {65418, 16}, {65419, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {26, 5}, {247, 8}, {1015, 10}, {4086, 12}, {32706, 15}, {65420, 16}, {65421, 16}, {65422, 16},
            {65423, 16}, {65424, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {27, 5}, {248, 8}, {1016, 10},
            {4087, 12}, {65425, 16}, {65426, 16}, {65427, 16}, {65428, 16}, {65429, 16}, {65430, 16}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {58, 6}, {502, 9}, {65431, 16}, {65432, 16}, {65433, 16}, {65434, 16},
            {65435, 16}, {65436, 16}, {65437, 16}, {65438, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {59, 6}, {1017, 10}, {65439, 16}, {65440, 16}, {65441, 16}, {65442, 16}, {65443, 16}, {65444, 16},
            {65445, 16}, {65446, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {121, 7}, {2039, 11},
            {65447, 16}, {65448, 16}, {65449, 16}, {65450, 16}, {65451, 16}, {65452, 16}, {65453, 16}, {65454, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {122, 7}, {2040, 11}, {65455, 16}, {65456, 16},
            {65457, 16}, {65458, 16}, {65459, 16}, {65460, 16}, {65461, 16}, {65462, 16}, {0, 0}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {249, 8}, {65463, 16}, {65464, 16}, {65465, 16}, {65466, 16},
            {65467, 16}, {65468, 16}, {65469, 16}, {65470, 16}, {65471, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {503, 9}, {65472, 16}, {65473, 16}, {65474, 16}, {65475, 16}, {65476, 16}, {65477, 16},
            {65478, 16}, {65479, 16}, {65480, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {504, 9},
            {65481, 16}, {65482, 16}, {65483, 16}, {65484, 16}, {65485, 16}, {65486, 16}, {65487, 16}, {65488, 16},
            {65489, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {505, 9}, {65490, 16}, {65491, 16},
            {65492, 16}, {65493, 16}, {65494, 16}, {65495, 16}, {65496, 16}, {65497, 16}, {65498, 16}, {0, 0},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {506, 9}, {65499, 16}, {65500, 16}, {65501, 16}, {65502, 16},
            {65503, 16}, {65504, 16}, {65505, 16}, {65506, 16}, {65507, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
            {0, 0}, {2041, 11}, {65508, 16}, {65509, 16}, {65510, 16}, {65511, 16}, {65512, 16}, {65513, 16},
            {65514, 16}, {65515, 16}, {65516, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {16352, 14},
            {65517, 16}, {65518, 16}, {65519, 16}, {65520, 16}, {65521, 16}, {65522, 16}, {65523, 16}, {65524, 16},
            {65525, 16}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1018, 10}, {32707, 15}, {65526, 16}, {65527, 16},
            {65528, 16}, {65529, 16}, {65530, 16}, {65531, 16}, {65532, 16}, {65533, 16}, {65534, 16},
            {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}
        };

        public static int[] YQT =
        {
            16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57,
            69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64,
            81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99
        };

        public static int[] UVQT =
        {
            17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99,
            99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
            99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
        };

        public static float[] aasf =
        {
            1f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f,
            1.175875602f * 2.828427125f, 1f * 2.828427125f, 0.785694958f * 2.828427125f,
            0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f
        };

        public static byte[] head0 =
        {
            0xFF, 0xD8, 0xFF, 0xE0, 0, 0x10, (byte)'J', (byte)'F', (byte)'I', (byte)'F',
            0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0xFF, 0xDB, 0, 0x84, 0
        };

        public static byte[] head2 = { 0xFF, 0xDA, 0, 0xC, 3, 1, 0, 2, 0x11, 3, 0x11, 0, 0x3F, 0 };

        #endregion

        #region Write Helpers

        public static void stbiw__putc(in WriteContext s, byte c)
        {
            Span<byte> tmp = stackalloc byte[] { c };
            s.Write(s, tmp);
        }

        public static int stbiw__write_pixel(
            in WriteContext s, bool flip_rgb, int alpha_dir,
            int expand_mono, Span<byte> pixel, Span<byte> output)
        {
            int offset = 0;

            if ((alpha_dir) < (0))
                output[offset++] = pixel[pixel.Length - 1];

            switch (pixel.Length)
            {
                case 1:
                case 2:
                    if ((expand_mono) != 0)
                    {
                        byte mono = pixel[0];
                        for (int i = 0; i < 3; i++)
                            output[offset++] = mono;
                    }
                    else
                    {
                        output[offset++] = pixel[0];
                    }
                    break;

                case 3:
                case 4:
                    int start = offset;
                    if (((pixel.Length) == (4)) && (alpha_dir == 0))
                    {
                        output[offset++] = (byte)(255 + ((pixel[0] - 255) * pixel[3]) / 255);
                        output[offset++] = (byte)((pixel[1] * pixel[3]) / 255);
                        output[offset++] = (byte)(255 + ((pixel[2] - 255) * pixel[3]) / 255);
                    }
                    else
                    {
                        for (int i = 0; i < 3; i++)
                            output[offset++] = pixel[i];
                    }

                    if (flip_rgb)
                    {
                        byte first = output[start];
                        output[start] = output[start + 2];
                        output[start + 2] = first;
                    }
                    break;
            }

            if ((alpha_dir) > (0))
                output[offset++] = pixel[pixel.Length - 1];

            return offset;
        }

        public static void stbiw__write_pixels(
            in WriteContext s, bool flip_rgb, int vdir,
            int alpha_dir, int scanline_pad, int expand_mono)
        {
            if (scanline_pad < 0 || scanline_pad > 4)
                throw new ArgumentOutOfRangeException(nameof(scanline_pad));

            if (s.Height <= 0)
                return;

            int i;
            int j;
            int j_end;
            if ((vdir) < (0))
            {
                j_end = -1;
                j = (int)(s.Height - 1);
            }
            else
            {
                j_end = (int)(s.Height);
                j = 0;
            }

            int x = s.Width;
            int comp = s.Comp;
            int stride = x * comp;

            int scratchSize = stride + scanline_pad;
            ScratchBuffer scratch = s.GetScratch(scratchSize);
            try
            {
                Span<byte> scratchSpan = scratch.AsSpan(0, scratchSize);
                Span<byte> scanlinePadSpan = scratchSpan.Slice(stride, scanline_pad);
                scanlinePadSpan.Fill(0);

                for (; j != j_end; j += (int)(vdir))
                {
                    s.ReadBytes(scratchSpan, j * stride);
                    int offset = 0;
                    for (i = 0; (i) < (x); ++i)
                    {
                        var pixel = scratchSpan.Slice(i * comp, comp);
                        var output = scratchSpan.Slice(offset, comp);
                        offset += stbiw__write_pixel(s, flip_rgb, alpha_dir, expand_mono, pixel, output);
                    }

                    if (offset != stride)
                    {
                        s.Write(s, scratchSpan.Slice(0, offset));
                        s.Write(s, scanlinePadSpan);
                    }
                    else
                        s.Write(s, scratchSpan);
                }
            }
            finally
            {
                scratch.Dispose();
            }
        }

        #endregion

        #region BMP

        public static int stbi_write_bmp_core(in WriteContext s)
        {
            // we only support RGB and RGBA, no palette indexing
            int bytesPerPixel = s.Comp == 4 ? 4 : 3;
            int bitDepth = bytesPerPixel * 8;

            int pad = (-s.Width * bytesPerPixel) & bytesPerPixel;
            int extraPad = s.Comp == 4 ? 68 : 0; // extra bytes for compression headers
            int dataSize = (s.Width * bytesPerPixel + pad) * s.Height;

            int dibHeaderLen = 40 + extraPad;
            int fileSize = 14 + dibHeaderLen + dataSize;
            int dataOffset = 14 + dibHeaderLen;
            int compression = s.Comp == 4 ? 3 : 0; // 3 == bitfields | 0 == no compression
            object[] headers = new object[]
            {
                (int)'B', (int)'M', fileSize, 0, 0, dataOffset, // BMP header
                dibHeaderLen, s.Width, s.Height, 1, bitDepth, compression, dataSize, 0, 0, 0, 0, // DIB header

                // needed for 32bit bitmaps
                0x00ff0000, 0x0000ff00, 0x000000ff, unchecked((int)0xff000000), // RGBA masks
                0x206E6957, // little-endian (equal to "Win ")
                0, 0, 0, 0, 0, 0, 0, 0, 0, // colorspace endpoints (unused)
                0, 0, 0 // RGB gamma (unused)
            };

            int alpha_dir = s.Comp == 4 ? 1 : 0;
            string fmt = extraPad > 0
                ? "11 4 22 44 44 22 444444 4444 4 444444444 444" // with compression headers
                : "11 4 22 44 44 22 444444";
            int headerCount = 17 + extraPad / 4; // we can divide by 4 as all the compression headers are int32
            return stbiw__outfile(s, true, -1, 1, alpha_dir, pad, fmt, headers.AsSpan(0, headerCount));
        }

        #endregion

        #region TGA

        public static int stbi_write_tga_core(in WriteContext s, bool writeRLE)
        {
            int x = s.Width;
            int y = s.Height;
            int comp = s.Comp;

            int has_alpha = (((comp) == (2)) || ((comp) == (4))) ? 1 : 0;
            int colorbytes = (int)((has_alpha) != 0 ? comp - 1 : comp);
            int format = (int)((colorbytes) < (2) ? 3 : 2);
            if (((y) < (0)) || ((x) < (0)))
                return 0;

            if (!writeRLE)
            {
                object[] headers = new object[]
                {
                    0, 0, (int)(format), 0, 0,
                    0, 0,
                    0, (int)(x), (int)(y), (int)((colorbytes + has_alpha) * 8), (int)(has_alpha * 8)
                };
                return stbiw__outfile(s, true, -1, 0, has_alpha, 0, "111 221 2222 11", headers);
            }
            else
            {
                int i;
                int j;
                int k;
                object[] headers = new object[]
                {
                    0, 0, (int)(format + 8), 0, 0,
                    0,
                    0, 0, (int)(x), (int)(y), (int)((colorbytes + has_alpha) * 8),
                    (int)(has_alpha * 8)
                };
                stbiw__writef(s, "111 221 2222 11", headers);

                byte* rowPixel = stackalloc byte[comp];
                byte* beginPixel = stackalloc byte[comp];
                byte* prevPixel = stackalloc byte[comp];

                Span<byte> rowPixelSpan = new Span<byte>(rowPixel, comp);
                Span<byte> beginPixelSpan = new Span<byte>(beginPixel, comp);
                Span<byte> prevPixelSpan = new Span<byte>(prevPixel, comp);

                Span<byte> headerBuffer = stackalloc byte[1];
                Span<byte> outputBuffer = stackalloc byte[4];
                for (j = (int)(y - 1); (j) >= (0); --j)
                {
                    int rowOffset = j * x * comp;

                    int len;
                    for (i = 0; (i) < (x); i += (int)(len))
                    {
                        int beginOffset = rowOffset + i * comp;
                        s.ReadBytes(beginPixelSpan, beginOffset);

                        int diff = 1;
                        len = 1;
                        if ((i) < (x - 1))
                        {
                            ++len;
                            s.ReadBytes(rowPixelSpan, rowOffset + (i + 1) * comp);
                            diff = (int)(CRuntime.memcmp(beginPixel, rowPixel, (ulong)(comp)));
                            if ((diff) != 0)
                            {
                                beginPixelSpan.CopyTo(prevPixelSpan);
                                int prevOffset = beginOffset;

                                for (k = (int)(i + 2); ((k) < (x)) && ((len) < (128)); ++k)
                                {
                                    s.ReadBytes(rowPixelSpan, rowOffset + k * comp);
                                    if ((CRuntime.memcmp(prevPixel, rowPixel, (ulong)(comp))) != 0)
                                    {
                                        s.ReadBytes(prevPixelSpan, prevOffset);
                                        prevOffset += comp;
                                        ++len;
                                    }
                                    else
                                    {
                                        --len;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                for (k = (int)(i + 2); ((k) < (x)) && ((len) < (128)); ++k)
                                {
                                    s.ReadBytes(rowPixelSpan, rowOffset + k * comp);
                                    if (CRuntime.memcmp(beginPixel, rowPixel, (ulong)(comp)) == 0)
                                        ++len;
                                    else
                                        break;
                                }
                            }
                        }

                        if ((diff) != 0)
                        {
                            headerBuffer[0] = (byte)((len - 1) & 0xff);
                            s.Write(s, headerBuffer);

                            for (k = 0; (k) < (len); ++k)
                            {
                                s.ReadBytes(beginPixelSpan, beginOffset + k * comp);
                                int pixlen = stbiw__write_pixel(s, true, has_alpha, 0, beginPixelSpan, outputBuffer);
                                s.Write(s, outputBuffer.Slice(0, pixlen));
                            }
                        }
                        else
                        {
                            headerBuffer[0] = (byte)((len - 129) & 0xff);
                            s.Write(s, headerBuffer);

                            int pixlen = stbiw__write_pixel(s, true, has_alpha, 0, beginPixelSpan, outputBuffer);
                            s.Write(s, outputBuffer.Slice(0, pixlen));
                        }
                    }
                }
            }

            return 1;
        }

        #endregion

        #region Radiance (HDR)

        public static void stbiw__linear_to_rgbe(Span<byte> rgbe, float* linear)
        {
            float maxcomp = (linear[0] > (linear[1] > linear[2] 
                ? linear[1] : linear[2]) 
                ? linear[0] : (linear[1] > linear[2] ? linear[1] : linear[2]));

            if (maxcomp < 1e-32f)
            {
                for (int i = 0; i < 4; i++)
                    rgbe[i] = 0;
            }
            else
            {
                float normalize = (float)(CRuntime.frexp(maxcomp, out int exponent) * 256.0 / maxcomp);
                rgbe[0] = ((byte)(linear[0] * normalize));
                rgbe[1] = ((byte)(linear[1] * normalize));
                rgbe[2] = ((byte)(linear[2] * normalize));
                rgbe[3] = ((byte)(exponent + 128));
            }
        }

        public static void stbiw__write_run_data(in WriteContext s, int length, byte databyte)
        {
            Span<byte> tmp = stackalloc byte[1];
            tmp[0] = (byte)((length + 128) & 0xff); // lengthbyte
            s.Write(s, tmp);

            tmp[0] = databyte;
            s.Write(s, tmp);
        }

        public static void stbiw__write_dump_data(in WriteContext s, int length, byte* data)
        {
            Span<byte> tmp = stackalloc byte[1];
            tmp[0] = (byte)((length) & 0xff); // lengthbyte
            s.Write(s, tmp);

            s.Write(s, new Span<byte>(data, length));
        }

        public static void stbiw__write_hdr_scanline(in WriteContext s, int y, byte* scratch)
        {
            int w = s.Width;
            int n = s.Comp;
            int x;

            Span<byte> scanlineheader = stackalloc byte[4];
            scanlineheader[0] = (byte)(2);
            scanlineheader[1] = (byte)(2);
            scanlineheader[2] = (byte)(0);
            scanlineheader[3] = (byte)(0);

            Span<byte> rgbe = stackalloc byte[4];
            float* linear = stackalloc float[3];
            scanlineheader[2] = (byte)((w & 0xff00) >> 8);
            scanlineheader[3] = (byte)(w & 0x00ff);

            Span<float> scanline = stackalloc float[n];
            if ((w < 8) || (w >= 32768))
            {
                for (x = 0; (x) < (w); x++)
                {
                    s.ReadFloats(scanline, (x + y * w) * n);

                    switch (n)
                    {
                        case 4:
                        case 3:
                            linear[0] = scanline[x * n + 0];
                            linear[1] = scanline[x * n + 1];
                            linear[2] = scanline[x * n + 2];
                            break;

                        default:
                            linear[0] = linear[1] = linear[2] = scanline[x * n + 0];
                            break;
                    }

                    stbiw__linear_to_rgbe(rgbe, linear);
                    s.Write(s, rgbe);
                }
            }
            else
            {
                for (x = 0; (x) < (w); x++)
                {
                    s.ReadFloats(scanline, (x + y * w) * n);

                    switch (n)
                    {
                        case 4:
                        case 3:
                            linear[0] = scanline[x * n + 0];
                            linear[1] = scanline[x * n + 1];
                            linear[2] = scanline[x * n + 2];
                            break;

                        default:
                            linear[0] = linear[1] = linear[2] = scanline[x * n + 0];
                            break;
                    }

                    stbiw__linear_to_rgbe(rgbe, linear);
                    scratch[x + w * 0] = (byte)(rgbe[0]);
                    scratch[x + w * 1] = (byte)(rgbe[1]);
                    scratch[x + w * 2] = (byte)(rgbe[2]);
                    scratch[x + w * 3] = (byte)(rgbe[3]);
                }

                s.Write(s, scanlineheader);

                for (int c = 0; (c) < (4); c++)
                {
                    byte* comp = &scratch[w * c];

                    x = 0;
                    while ((x) < (w))
                    {
                        int r = (int)(x);
                        while ((r + 2) < (w))
                        {
                            if (((comp[r]) == (comp[r + 1])) && ((comp[r]) == (comp[r + 2])))
                                break;
                            ++r;
                        }

                        if ((r + 2) >= (w))
                            r = (int)(w);

                        while ((x) < (r))
                        {
                            int len = (int)(r - x);
                            if ((len) > (128))
                                len = (int)(128);
                            stbiw__write_dump_data(s, (int)(len), &comp[x]);
                            x += (int)(len);
                        }

                        if ((r + 2) < (w))
                        {
                            while (((r) < (w)) && ((comp[r]) == (comp[x])))
                                ++r;

                            while ((x) < (r))
                            {
                                int len = (int)(r - x);
                                if ((len) > (127))
                                    len = (int)(127);
                                stbiw__write_run_data(s, (int)(len), (byte)(comp[x]));
                                x += (int)(len);
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region PNG

        #region zlib Deflate

        /// <summary>
        /// Delegate for a zlib deflate (RFC 1951) compression implementation.
        /// </summary>
        public delegate IMemoryResult ZlibDeflateCompressDelegate(
            ReadOnlySpan<byte> data, CompressionLevel level, WriteProgressCallback onProgress);

        /// <summary>
        /// Custom zlib deflate (RFC 1951) compression implementation 
        /// that replaces the default <see cref="zlib_deflate_compress"/>.
        /// </summary>
        public static ZlibDeflateCompressDelegate CustomZlibDeflateCompress;

        // TODO: copy adler32 implementation from zlib library (as it's should be faster)
        public static uint calc_adler32_checksum(ReadOnlySpan<byte> data)
        {
            uint s1 = 1;
            uint s2 = 0;

            int j = 0;
            int blocklen = (int)(data.Length % 5552);

            while (j < data.Length)
            {
                for (int i = 0; i < blocklen; ++i)
                {
                    s1 += data[j + i];
                    s2 += s1;
                }
                s1 %= 65521;
                s2 %= 65521;
                j += blocklen;
                blocklen = 5552;
            }

            return (s2 << 16) | s1;
        }

        /// <summary>
        /// Compresses data using a <see cref="DeflateStream"/> and
        /// adds zlib (RFC 1951) headers and checksum.
        /// <para>Can be replaced by assigning <see cref="CustomZlibDeflateCompress"/>.</para>
        /// </summary>
        public static IMemoryResult zlib_deflate_compress(
            ReadOnlySpan<byte> data, CompressionLevel level, WriteProgressCallback onProgress)
        {
            if (CustomZlibDeflateCompress != null)
                return CustomZlibDeflateCompress.Invoke(data, level, onProgress);

            var output = new MemoryStream();
            var header = ZlibHeader.CreateForDeflateStream(level);
            output.WriteByte(header.GetCMF());
            output.WriteByte(header.GetFLG());

            byte[] copyBuffer = new byte[1024 * 8];
            fixed (byte* dataPtr = &MemoryMarshal.GetReference(data))
            {
                using (var deflate = new DeflateStream(output, level, leaveOpen: true))
                using (var source = new UnmanagedMemoryStream(dataPtr, data.Length))
                {
                    // we don't want to use Stream.CopyTo as we want progress reporting
                    int total = 0;
                    int read;
                    while ((read = source.Read(copyBuffer, 0, copyBuffer.Length)) != 0)
                    {
                        deflate.Write(copyBuffer, 0, read);
                    
                        total += read;
                        onProgress?.Invoke(total / (double)data.Length);
                    }
                }
            }

            uint adler32 = calc_adler32_checksum(data);
            byte[] adlerBytes = BitConverter.GetBytes(adler32);
            adlerBytes.AsSpan().Reverse();
            output.Write(adlerBytes, 0, adlerBytes.Length);

            byte[] result = output.GetBuffer();
            var gcHandle = GCHandle.Alloc(result, GCHandleType.Pinned);
            return new GCHandleResult(gcHandle, (int)output.Length);
        }

        #endregion

        // TODO: add more color formats and a palette
        // TODO: split IDAT chunk into multiple
        // http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html

        public static bool stbi_write_png_core(in WriteContext s, CompressionLevel level)
        {
            ZlibHeader.ConvertLevel(level); // acts as a parameter check

            int w = s.Width;
            int h = s.Height;
            int n = s.Comp;
            int stride = (int)(w * n);

            int force_filter = (int)(stbi_png_write_force_filter);
            if (force_filter >= (5))
                force_filter = -1;

            int filtLength = (stride + 1) * h;
            byte* filt = (byte*)(CRuntime.malloc(filtLength));
            if (filt == null)
                return false;

            sbyte* line_buffer = (sbyte*)(CRuntime.malloc((ulong)stride));
            if (line_buffer == null)
            {
                CRuntime.free(filt);
                return false;
            }

            double progressStep = 0;
            int pixels = w * h;
            double progressStepCount = pixels / (1000 * Math.Log(pixels, 2));
            double progressStepSize = Math.Max(1, pixels / progressStepCount);

            ScratchBuffer pixelRowScratch = s.GetScratch(stride);
            try
            {
                Span<byte> pixelRow = pixelRowScratch.AsSpan();
                fixed (byte* pixelRowPtr = &MemoryMarshal.GetReference(pixelRow))
                {
                    for (int y = 0; (y) < (h); ++y)
                    {
                        s.ReadBytes(pixelRow, y * stride);

                        int filter_type = 0;
                        if (force_filter > (-1))
                        {
                            filter_type = (int)force_filter;
                            stbiw__encode_png_line(
                                pixelRowPtr, (stride), (w), (h), (y), (n), force_filter, line_buffer);
                        }
                        else
                        {
                            int best_filter = 0;
                            int best_filter_val = (int)(0x7fffffff);
                            int est = 0;
                            int i = 0;
                            for (filter_type = 0; (filter_type) < (5); filter_type++)
                            {
                                stbiw__encode_png_line(
                                    pixelRowPtr, (stride), (w), (h), (y), (n), (filter_type), line_buffer);

                                est = 0;
                                for (i = 0; (i) < stride; ++i)
                                    est += (int)(CRuntime.FastAbs((int)(line_buffer[i])));

                                if ((est) < (best_filter_val))
                                {
                                    best_filter_val = (int)(est);
                                    best_filter = (int)(filter_type);
                                }
                            }

                            if (filter_type != best_filter)
                            {
                                stbiw__encode_png_line(
                                    pixelRowPtr, (stride), (w), (h), (y), (n), (best_filter), line_buffer);
                                filter_type = (int)(best_filter);
                            }
                        }

                        filt[y * (stride + 1)] = (byte)filter_type;
                        CRuntime.memcpy(filt + y * (stride + 1) + 1, line_buffer, (ulong)(stride));

                        // TODO: tidy this up a notch so it's easier to reuse in other implementations
                        if (s.Progress != null)
                        {
                            progressStep += w;
                            while (progressStep >= progressStepSize)
                            {
                                s.Progress(y / (double)h * 0.5);
                                progressStep -= progressStepSize;
                            }
                        }
                    }
                }
            }
            catch
            {
                CRuntime.free(filt);
                throw;
            }
            finally
            {
                CRuntime.free(line_buffer);
                pixelRowScratch.Dispose();
            }

            IMemoryResult compressed;
            try
            {
                WriteProgressCallback weightedProgress = null;
                if (s.Progress != null)
                {
                    var wpc = s.Progress;
                    weightedProgress = (p) => wpc.Invoke(p * 0.49 + 0.5);
                }

                var filtSpan = new ReadOnlySpan<byte>(filt, filtLength);
                compressed = zlib_deflate_compress(filtSpan, level, weightedProgress);
                if (compressed == null)
                    return false;
            }
            finally
            {
                CRuntime.free(filt);
            }

            try
            {
                int* colorTypeMap = stackalloc int[5];
                colorTypeMap[0] = -1;
                colorTypeMap[1] = 0;
                colorTypeMap[2] = (int)(4);
                colorTypeMap[3] = (int)(2);
                colorTypeMap[4] = (int)(6);

                // sizeof sig + (fields + CRCs)
                Span<byte> tmp = stackalloc byte[8 + sizeof(uint) * (5 + 2) + 5];
                int pos = 0;

                #region PNG Signature

                tmp[pos++] = 137;
                tmp[pos++] = 80;
                tmp[pos++] = 78;
                tmp[pos++] = 71;
                tmp[pos++] = 13;
                tmp[pos++] = 10;
                tmp[pos++] = 26;
                tmp[pos++] = 10;

                #endregion

                #region IHDR chunk

                var hdrChunk = new PngChunk(13, "IHDR");
                hdrChunk.WriteHeader(tmp, ref pos);

                hdrChunk.SlurpWriteUInt32((uint)w, tmp, ref pos); // width
                hdrChunk.SlurpWriteUInt32((uint)h, tmp, ref pos); // height

                byte colorType = (byte)(colorTypeMap[n] & 0xff);
                hdrChunk.SlurpWriteInt8(8, tmp, ref pos); // bit depth
                hdrChunk.SlurpWriteInt8(colorType, tmp, ref pos); // color type
                hdrChunk.SlurpWriteInt8(0, tmp, ref pos); // compression method
                hdrChunk.SlurpWriteInt8(0, tmp, ref pos); // filter method
                hdrChunk.SlurpWriteInt8(0, tmp, ref pos); // interlace method

                hdrChunk.WriteFooter(tmp, ref pos);

                #endregion

                // TODO: write multiple IDAT chunks instead of one large to lower memory usage,
                //       this requires quite a lot of work as the encoding needs to be redesigned

                #region IDAT chunk

                var datChunk = new PngChunk(compressed.Length, "IDAT");
                datChunk.WriteHeader(tmp, ref pos);

                s.Write(s, tmp.Slice(0, pos));
                pos = 0;

                var compressedSpan = new Span<byte>((void*)compressed.Pointer, compressed.Length);
                if (s.Progress != null)
                {
                    int written = 0;
                    while (written < compressed.Length)
                    {
                        int sliceLength = Math.Min(compressed.Length - written, s.WriteBuffer.Length);
                        s.Write(s, compressedSpan.Slice(written, sliceLength));

                        written += sliceLength;
                        s.Progress(written / (double)compressed.Length * 0.01 + 0.99);
                    }
                }
                else
                {
                    // skip some overhead if the progress callback is null
                    s.Write(s, compressedSpan);
                }

                datChunk.SlurpData(compressedSpan);
                datChunk.WriteFooter(tmp, ref pos);

                #endregion

                #region IEND chunk

                var endChunk = new PngChunk(0, "IEND");
                endChunk.WriteHeader(tmp, ref pos);
                endChunk.WriteFooter(tmp, ref pos);

                s.Write(s, tmp.Slice(0, pos));

                #endregion

                return true;
            }
            finally
            {
                compressed.Dispose();
            }
        }

        #region PngChunk

        private struct PngChunk
        {
            public readonly uint Length;
            public readonly uint Type;
            public uint Crc;

            public unsafe PngChunk(int length, string type)
            {
                if (length < 0)
                    throw new ArgumentOutOfRangeException(nameof(length), "The value may not be negative.");
                if (type == null)
                    throw new ArgumentNullException(nameof(type));
                if (type.Length != 4)
                    throw new ArgumentException(nameof(type), "The type must be exactly 4 characters long.");

                uint u32Type = 0;
                var u32TypeSpan = new Span<byte>(&u32Type, sizeof(uint));
                for (int i = 0; i < type.Length; i++)
                {
                    if (type[i] > byte.MaxValue)
                        throw new ArgumentException(
                            nameof(type), "The character '" + type[i] + "' is invalid.");
                    u32TypeSpan[i] = (byte)type[i];
                }

                // write_uint writes u32 as big endian but the type should be 
                // little endian so it needs to be reversed for write_uint,
                // but after calculating the crc
                uint crc = stbiw__calc_crc32(u32TypeSpan);
                u32TypeSpan.Reverse();

                Length = (uint)length;
                Type = u32Type;
                Crc = crc;
            }

            public void WriteHeader(Span<byte> output, ref int position)
            {
                write_uint(Length, output, ref position);
                write_uint(Type, output, ref position);
            }

            public void WriteFooter(Span<byte> output, ref int position)
            {
                write_uint(~Crc, output, ref position);
            }

            #region Slurp

            public void SlurpData(ReadOnlySpan<byte> data)
            {
                Crc = stbiw__calc_crc32(data, Crc);
            }

            private void SlurpWrite(Span<byte> span, int size, int position)
            {
                SlurpData(span.Slice(position - size, size));
            }

            public void SlurpWriteUInt32(uint value, Span<byte> output, ref int position)
            {
                write_uint(value, output, ref position);
                SlurpWrite(output, sizeof(uint), position);
            }

            public void SlurpWriteInt8(byte value, Span<byte> output, ref int position)
            {
                output[position++] = value;
                SlurpWrite(output, sizeof(byte), position);
            }

            #endregion
        }

        #endregion

        public static void stbiw__encode_png_line(
            byte* pixels, int stride_bytes, int width, int height, int y,
            int n, int filter_type, sbyte* line_buffer)
        {
            int* mapping = stackalloc int[5];
            mapping[0] = 0;
            mapping[1] = 1;
            mapping[2] = (int)(2);
            mapping[3] = (int)(3);
            mapping[4] = (int)(4);

            int* firstmap = stackalloc int[5];
            firstmap[0] = 0;
            firstmap[1] = 1;
            firstmap[2] = 0;
            firstmap[3] = (int)(5);
            firstmap[4] = (int)(6);

            int* mymap = (y != 0) ? mapping : firstmap;
            int i = 0;
            int stride = width * n;
            int type = (int)(mymap[filter_type]);
            byte* z = pixels; // + stride_bytes * ((stbi__flip_vertically_on_write) != 0 ? height - 1 - y : y);
            int signed_stride = (int)((stbi__flip_vertically_on_write) != 0 ? -stride_bytes : stride_bytes);
            if ((type) == 0)
            {
                CRuntime.memcpy(line_buffer, z, (ulong)(stride));
                return;
            }

            i = 0;
            switch (type)
            {
                case 1:
                case 5:
                case 6:
                    if (n == 4)
                        *((int*)line_buffer) = *((int*)z);
                    else
                        for (; i < n; ++i)
                            line_buffer[i] = (sbyte)(z[i]);
                    break;

                case 2:
                    for (; i < n; ++i)
                        line_buffer[i] = (sbyte)(z[i] - z[i - signed_stride]);
                    break;

                case 3:
                    for (; i < n; ++i)
                        line_buffer[i] = (sbyte)(z[i] - (z[i - signed_stride] >> 1));
                    break;

                case 4:
                    for (; i < n; ++i)
                        line_buffer[i] = ((sbyte)(z[i] - CRuntime.Paeth32(0, z[i - signed_stride], 0)));
                    break;
            }

            i = n;
            switch (type)
            {
                case 1:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - z[i - n]);
                    break;

                case 2:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - z[i - signed_stride]);
                    break;

                case 3:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - ((z[i - n] + z[i - signed_stride]) >> 1));
                    break;

                case 4:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - CRuntime.Paeth32(
                            (int)(z[i - n]), (int)(z[i - signed_stride]), (int)(z[i - signed_stride - n])));
                    break;

                case 5:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - (z[i - n] >> 1));
                    break;

                case 6:
                    for (; (i) < stride; ++i)
                        line_buffer[i] = (sbyte)(z[i] - CRuntime.Paeth32((int)(z[i - n]), 0, 0));
                    break;
            }
        }

        public static void set_uint(uint value, Span<byte> output)
        {
            output[0] = ((byte)((value >> 24) & 0xff));
            output[1] = ((byte)((value >> 16) & 0xff));
            output[2] = ((byte)((value >> 8) & 0xff));
            output[3] = ((byte)((value) & 0xff));
        }

        public static void write_uint(uint value, Span<byte> output, ref int position)
        {
            set_uint(value, output.Slice(position));
            position += sizeof(uint);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint stbiw__calc_crc32(byte value, uint crc)
        {
            return (crc >> 8) ^ crc_table[value ^ (crc & 0xff)];
        }

        public static uint stbiw__calc_crc32(ReadOnlySpan<byte> buffer, uint baseCrc = ~0u)
        {
            uint crc = baseCrc;
            for (int i = 0; i < buffer.Length; ++i)
                crc = stbiw__calc_crc32(buffer[i], crc);
            return crc;
        }

        #endregion

        #region JPG

        public static void stbiw__jpg_writeBits(
            in WriteContext s, int* bitBufP, int* bitCntP, ushort bs0, ushort bs1)
        {
            int bitBuf = (int)(*bitBufP);
            int bitCnt = (int)(*bitCntP);
            bitCnt += (int)(bs1);
            bitBuf |= (int)(bs0 << (24 - bitCnt));
            while ((bitCnt) >= (8))
            {
                byte c = (byte)((bitBuf >> 16) & 255);
                stbiw__putc(s, (byte)(c));
                if ((c) == (255))
                    stbiw__putc(s, 0);

                bitBuf <<= 8;
                bitCnt -= (int)(8);
            }

            *bitBufP = (int)(bitBuf);
            *bitCntP = (int)(bitCnt);
        }

        public static void stbiw__jpg_DCT(
            float* d0p, float* d1p, float* d2p, float* d3p,
            float* d4p, float* d5p, float* d6p, float* d7p)
        {
            float d0 = (float)(*d0p);
            float d1 = (float)(*d1p);
            float d2 = (float)(*d2p);
            float d3 = (float)(*d3p);
            float d4 = (float)(*d4p);
            float d5 = (float)(*d5p);
            float d6 = (float)(*d6p);
            float d7 = (float)(*d7p);
            float tmp0 = (float)(d0 + d7);
            float tmp7 = (float)(d0 - d7);
            float tmp1 = (float)(d1 + d6);
            float tmp6 = (float)(d1 - d6);
            float tmp2 = (float)(d2 + d5);
            float tmp5 = (float)(d2 - d5);
            float tmp3 = (float)(d3 + d4);
            float tmp4 = (float)(d3 - d4);
            float tmp10 = (float)(tmp0 + tmp3);
            float tmp13 = (float)(tmp0 - tmp3);
            float tmp11 = (float)(tmp1 + tmp2);
            float tmp12 = (float)(tmp1 - tmp2);
            d0 = (float)(tmp10 + tmp11);
            d4 = (float)(tmp10 - tmp11);
            tmp10 = (float)(tmp4 + tmp5);
            tmp11 = (float)(tmp5 + tmp6);
            tmp12 = (float)(tmp6 + tmp7);

            float z1 = (float)((tmp12 + tmp13) * 0.707106781f);
            d2 = (float)(tmp13 + z1);
            d6 = (float)(tmp13 - z1);

            float z5 = (float)((tmp10 - tmp12) * 0.382683433f);
            float z2 = (float)(tmp10 * 0.541196100f + z5);
            float z4 = (float)(tmp12 * 1.306562965f + z5);
            float z3 = (float)(tmp11 * 0.707106781f);
            float z11 = (float)(tmp7 + z3);
            float z13 = (float)(tmp7 - z3);

            *d5p = (float)(z13 + z2);
            *d3p = (float)(z13 - z2);
            *d1p = (float)(z11 + z4);
            *d7p = (float)(z11 - z4);
            *d0p = (float)(d0);
            *d2p = (float)(d2);
            *d4p = (float)(d4);
            *d6p = (float)(d6);
        }

        public static void stbiw__jpg_calcBits(int val, ushort* bits)
        {
            int tmp1 = (int)((val) < (0) ? -val : val);
            val = (int)((val) < (0) ? val - 1 : val);
            bits[1] = (ushort)(1);
            while ((tmp1 >>= 1) != 0)
            {
                ++bits[1];
            }

            bits[0] = (ushort)(val & ((1 << bits[1]) - 1));
        }

        public static int stbiw__jpg_processDU(
            in WriteContext s, int* bitBuf, int* bitCnt, float* CDU,
            float* fdtbl, int DC, ushort[,] HTDC, ushort[,] HTAC)
        {
            ushort* EOB = stackalloc ushort[2];
            EOB[0] = (ushort)(HTAC[0x00, 0]);
            EOB[1] = (ushort)(HTAC[0x00, 1]);

            ushort* M16zeroes = stackalloc ushort[2];
            M16zeroes[0] = (ushort)(HTAC[0xF0, 0]);
            M16zeroes[1] = (ushort)(HTAC[0xF0, 1]);

            int dataOff;
            int i;
            int diff;
            int end0pos;
            int* DU = stackalloc int[64];
            ushort* bits = stackalloc ushort[2];

            for (dataOff = 0; (dataOff) < (64); dataOff += (int)(8))
            {
                stbiw__jpg_DCT(
                    &CDU[dataOff], &CDU[dataOff + 1], &CDU[dataOff + 2], &CDU[dataOff + 3],
                    &CDU[dataOff + 4], &CDU[dataOff + 5], &CDU[dataOff + 6], &CDU[dataOff + 7]);
            }

            for (dataOff = 0; (dataOff) < (8); ++dataOff)
            {
                stbiw__jpg_DCT(
                    &CDU[dataOff], &CDU[dataOff + 8], &CDU[dataOff + 16], &CDU[dataOff + 24],
                    &CDU[dataOff + 32], &CDU[dataOff + 40], &CDU[dataOff + 48], &CDU[dataOff + 56]);
            }

            for (i = 0; (i) < (64); ++i)
            {
                float v = (float)(CDU[i] * fdtbl[i]);
                DU[stbiw__jpg_ZigZag[i]] = ((int)((v) < (0) ? v - 0.5f : v + 0.5f));
            }

            diff = (int)(DU[0] - DC);
            if ((diff) == 0)
            {
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0, 0], HTDC[0, 1]);
            }
            else
            {
                stbiw__jpg_calcBits((int)(diff), bits);
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1], 0], HTDC[bits[1], 1]);
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits[0], bits[1]);
            }

            end0pos = (int)(63);
            for (; ((end0pos) > (0)) && ((DU[end0pos]) == 0); --end0pos)
            {
            }

            if ((end0pos) == 0)
            {
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB[0], EOB[1]);
                return (int)(DU[0]);
            }

            for (i = 1; i <= end0pos; ++i)
            {
                int startpos = (int)(i);
                int nrzeroes;
                for (; ((DU[i]) == 0) && (i <= end0pos); ++i)
                {
                }

                nrzeroes = (int)(i - startpos);
                if ((nrzeroes) >= (16))
                {
                    int lng = (int)(nrzeroes >> 4);
                    for (int nrmarker = 1; nrmarker <= lng; ++nrmarker)
                        stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes[0], M16zeroes[1]);

                    nrzeroes &= (int)(15);
                }

                stbiw__jpg_calcBits((int)(DU[i]), bits);
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes << 4) + bits[1], 0],
                    HTAC[(nrzeroes << 4) + bits[1], 1]);
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits[0], bits[1]);
            }

            if (end0pos != 63)
                stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB[0], EOB[1]);

            return (int)(DU[0]);
        }

        public static int stbi_write_jpg_core(in WriteContext s, /*bool useFloat,*/ int quality)
        {
            int width = s.Width;
            int height = s.Height;
            int comp = s.Comp;

            if ((s.ReadBytes == null) || (width == 0) || (height == 0) || (comp > 4) || (comp < 1))
                return 0;

            int row;
            int col;
            int i;
            int k;
            float* fdtbl_Y = stackalloc float[64];
            float* fdtbl_UV = stackalloc float[64];
            Span<byte> YTable = stackalloc byte[64];
            Span<byte> UVTable = stackalloc byte[64];

            quality = (int)((quality) != 0 ? quality : 90);
            quality = (int)((quality) < (1) ? 1 : (quality) > (100) ? 100 : quality);
            quality = (int)((quality) < (50) ? 5000 / quality : 200 - quality * 2);

            for (i = 0; (i) < (64); ++i)
            {
                int yti = (int)((YQT[i] * quality + 50) / 100);
                YTable[stbiw__jpg_ZigZag[i]] = ((byte)((yti) < (1) ? 1 : (yti) > (255) ? 255 : yti));
                int uvti = (int)((UVQT[i] * quality + 50) / 100);
                UVTable[stbiw__jpg_ZigZag[i]] = ((byte)((uvti) < (1) ? 1 : (uvti) > (255) ? 255 : uvti));
            }

            for (row = 0, k = 0; (row) < (8); ++row)
            {
                for (col = 0; (col) < (8); ++col, ++k)
                {
                    fdtbl_Y[k] = (float)(1 / (YTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]));
                    fdtbl_UV[k] = (float)(1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]));
                }
            }

            {
                Span<byte> head1 = stackalloc byte[24];
                head1[0] = (byte)(0xFF);
                head1[1] = (byte)(0xC0);
                head1[2] = (byte)(0);
                head1[3] = (byte)(0x11);
                head1[4] = (byte)(8);
                head1[5] = (byte)(height >> 8);
                head1[6] = (byte)((height) & 0xff);
                head1[7] = (byte)(width >> 8);
                head1[8] = (byte)((width) & 0xff);
                head1[9] = (byte)(3);
                head1[10] = (byte)(1);
                head1[11] = (byte)(0x11);
                head1[12] = (byte)(0);
                head1[13] = (byte)(2);
                head1[14] = (byte)(0x11);
                head1[15] = (byte)(1);
                head1[16] = (byte)(3);
                head1[17] = (byte)(0x11);
                head1[18] = (byte)(1);
                head1[19] = (byte)(0xFF);
                head1[20] = (byte)(0xC4);
                head1[21] = (byte)(0x01);
                head1[22] = (byte)(0xA2);
                head1[23] = (byte)(0);

                s.Write(s, head0);

                s.Write(s, YTable);
                stbiw__putc(s, (byte)(1));
                s.Write(s, UVTable);
                s.Write(s, head1);

                s.Write(s, std_dc_luminance_nrcodes.AsSpan(1, std_dc_chrominance_nrcodes.Length - 1));
                s.Write(s, std_dc_luminance_values.AsSpan(0, std_dc_chrominance_values.Length));

                stbiw__putc(s, (byte)(0x10));

                s.Write(s, std_ac_luminance_nrcodes.AsSpan(1));
                s.Write(s, std_ac_luminance_values);

                stbiw__putc(s, (byte)(1));

                s.Write(s, std_dc_chrominance_nrcodes.AsSpan(1));
                s.Write(s, std_dc_chrominance_values);

                stbiw__putc(s, (byte)(0x11));

                s.Write(s, std_ac_chrominance_nrcodes.AsSpan(1));
                s.Write(s, std_ac_chrominance_values);

                s.Write(s, head2);
            }

            {
                int DCY = 0;
                int DCU = 0;
                int DCV = 0;
                int bitBuf = 0;
                int bitCnt = 0;
                int stride = width * comp;
                int x;
                int y;
                int pos;
                float* YDU = stackalloc float[64];
                float* UDU = stackalloc float[64];
                float* VDU = stackalloc float[64];
                Span<byte> byteDataBuffer = stackalloc byte[comp > 2 ? 3 : 1];
                //Span<float> floatDataBuffer = stackalloc float[comp > 2 ? 3 : 1];
                float r, g, b;

                for (y = 0; (y) < (height); y += 8)
                {
                    for (x = 0; (x) < (width); x += 8)
                    {
                        for (row = (int)(y), pos = 0; (row) < (y + 8); ++row)
                        {
                            for (col = (int)(x); (col) < (x + 8); ++col, ++pos)
                            {
                                int p = (int)(row * stride + col * comp);

                                if (row >= height)
                                    p -= (int)(stride * (row + 1 - height));

                                if (col >= width)
                                    p -= (int)(comp * (col + 1 - width));

                                //if (useFloat)
                                //{
                                //    s.GetFloatPixels(floatDataBuffer, p);
                                //    if (comp > 2)
                                //    {
                                //        r = floatDataBuffer[0];
                                //        g = floatDataBuffer[1];
                                //        b = floatDataBuffer[2];
                                //    }
                                //    else
                                //        r = g = b = floatDataBuffer[0];
                                //
                                //    YDU[pos] = (float)(+0.29900f * r + 0.58700f * g + 0.11400f * b - 128);
                                //    UDU[pos] = (float)(-0.16874f * r - 0.33126f * g + 0.50000f * b);
                                //    VDU[pos] = (float)(+0.50000f * r - 0.41869f * g - 0.08131f * b);
                                //}
                                //else
                                {
                                    s.ReadBytes(byteDataBuffer, p);
                                    if (comp > 2)
                                    {
                                        r = (float)(byteDataBuffer[0]);
                                        g = (float)(byteDataBuffer[1]);
                                        b = (float)(byteDataBuffer[2]);
                                    }
                                    else
                                        r = g = b = (float)byteDataBuffer[0];

                                    YDU[pos] = (float)(+0.29900f * r + 0.58700f * g + 0.11400f * b - 128);
                                    UDU[pos] = (float)(-0.16874f * r - 0.33126f * g + 0.50000f * b);
                                    VDU[pos] = (float)(+0.50000f * r - 0.41869f * g - 0.08131f * b);
                                }
                            }
                        }

                        DCY = (int)(stbiw__jpg_processDU(s, &bitBuf, &bitCnt, YDU, fdtbl_Y, (int)(DCY), YDC_HT, YAC_HT));
                        DCU = (int)(stbiw__jpg_processDU(s, &bitBuf, &bitCnt, UDU, fdtbl_UV, (int)(DCU), UVDC_HT, UVAC_HT));
                        DCV = (int)(stbiw__jpg_processDU(s, &bitBuf, &bitCnt, VDU, fdtbl_UV, (int)(DCV), UVDC_HT, UVAC_HT));
                    }
                }

                stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, 0x7F, 7);
            }

            stbiw__putc(s, (byte)(0xFF));
            stbiw__putc(s, (byte)(0xD9));
            return 1;
        }

        #endregion
    }
}